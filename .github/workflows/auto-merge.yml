name: Auto Merge PR

on:
  pull_request:
    types: [labeled]
  workflow_run:
    workflows: ["PR Reviewer"]
    types: [completed]

jobs:
  auto-merge:
    runs-on: self-hosted
    permissions:
      contents: write
      pull-requests: write
      checks: read
    
    # Skip job if auto-merging label is already present
    if: >
      (github.event_name == 'pull_request' && 
       !contains(github.event.pull_request.labels.*.name, 'auto-merging')) ||
      github.event_name == 'workflow_run'
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}
          fetch-depth: 0
      
      - name: Check for auto-merge eligibility
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            let prNumber;
            
            // Handle different trigger types
            if (context.eventName === 'pull_request') {
              prNumber = context.payload.pull_request.number;
              console.log(`Triggered by label on PR #${prNumber}`);
            } else if (context.eventName === 'workflow_run') {
              // Find PR from the completed workflow
              const headBranch = context.payload.workflow_run.head_branch;
              console.log(`Triggered by completed workflow for branch: ${headBranch}`);
              
              const prs = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                head: `${context.repo.owner}:${headBranch}`,
                state: 'open'
              });
              
              if (prs.data.length === 0) {
                console.log('No open PR found for branch');
                return;
              }
              
              prNumber = prs.data[0].number;
              console.log(`Found PR #${prNumber} for branch ${headBranch}`);
            } else {
              console.log('Unknown trigger event');
              return;
            }
            
            // Get PR details and labels
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            
            const labels = await github.rest.issues.listLabelsOnIssue({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber
            });
            
            const labelNames = labels.data.map(l => l.name);
            console.log('PR labels:', labelNames);
            
            // Check if merge is already in progress - exit immediately to avoid race conditions
            if (labelNames.includes('auto-merging')) {
              console.log('Auto-merge already in progress - skipping duplicate merge attempt');
              return;
            }
            
            // Check if PR is eligible for auto-merge
            if (!labelNames.includes('ready-to-merge')) {
              console.log('PR not labeled as ready-to-merge - skipping auto-merge');
              return;
            }
            
            // Additional safety checks
            if (pr.data.draft) {
              console.log('PR is draft - cannot auto-merge');
              return;
            }
            
            if (pr.data.state !== 'open') {
              console.log('PR is not open - cannot auto-merge');
              return;
            }
            
            // Check for blocking labels
            const blockingLabels = ['needs-manual-review', 'do-not-merge', 'wip', 'work-in-progress'];
            const hasBlockingLabel = blockingLabels.some(label => labelNames.includes(label));
            
            if (hasBlockingLabel) {
              console.log('PR has blocking labels - cannot auto-merge');
              return;
            }
            
            // Check if all required status checks pass
            const checks = await github.rest.checks.listForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: pr.data.head.sha
            });
            
            const failedChecks = checks.data.check_runs.filter(check => 
              check.status === 'completed' && check.conclusion === 'failure'
            );
            
            if (failedChecks.length > 0) {
              console.log('Some status checks failed - cannot auto-merge');
              console.log('Failed checks:', failedChecks.map(c => c.name));
              return;
            }
            
            // Check if there are pending required reviews
            const reviews = await github.rest.pulls.listReviews({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            
            const latestReviews = new Map();
            reviews.data.forEach(review => {
              if (review.state !== 'COMMENTED') {
                latestReviews.set(review.user.login, review.state);
              }
            });
            
            const hasChangeRequests = Array.from(latestReviews.values()).includes('CHANGES_REQUESTED');
            
            if (hasChangeRequests) {
              console.log('PR has unresolved change requests - cannot auto-merge');
              return;
            }
            
            console.log('All checks passed - proceeding with auto-merge');
            
            // Add auto-merging label for tracking
            try {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                labels: ['auto-merging']
              });
            } catch (e) {
              console.log('Could not add auto-merging label:', e.message);
            }
            
            // Perform the merge
            try {
              const mergeResult = await github.rest.pulls.merge({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                commit_title: `Auto-merge: ${pr.data.title} (#${prNumber})`,
                commit_message: `${pr.data.body || 'No description provided'}\n\nü§ñ Auto-merged after successful review and validation`,
                merge_method: 'squash' // You can change this to 'merge' or 'rebase' as needed
              });
              
              console.log('PR successfully auto-merged');
              console.log('Merge SHA:', mergeResult.data.sha);
              
              // Add comment about successful auto-merge
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: `‚úÖ **Auto-merge completed successfully**\n\nThis PR was automatically merged after:\n- ‚úÖ All status checks passed\n- ‚úÖ No blocking labels present\n- ‚úÖ No pending change requests\n- ‚úÖ Labeled as ready-to-merge\n\nMerge SHA: ${mergeResult.data.sha}\n\nü§ñ Generated with [Claude Code](https://claude.ai/code)`
              });
              
              // Remove temporary labels
              try {
                const labelsToRemove = ['auto-merging', 'ready-to-merge', 'review-completed'];
                for (const labelName of labelsToRemove) {
                  if (labelNames.includes(labelName)) {
                    await github.rest.issues.removeLabel({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: prNumber,
                      name: labelName
                    });
                  }
                }
              } catch (e) {
                console.log('Could not remove labels:', e.message);
              }
              
              // Delete the feature branch after successful merge
              try {
                const branchName = pr.data.head.ref;
                console.log(`Deleting branch: ${branchName}`);
                
                await github.rest.git.deleteRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `heads/${branchName}`
                });
                
                console.log(`Branch ${branchName} deleted successfully`);
              } catch (e) {
                console.log('Could not delete branch:', e.message);
                // Don't fail the workflow if branch deletion fails
              }
              
            } catch (error) {
              console.log('Auto-merge failed:', error.message);
              
              // Add comment about failed auto-merge
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: `‚ùå **Auto-merge failed**\n\nReason: ${error.message}\n\nPlease merge manually or resolve the issue.`
              });
              
              // Remove auto-merging label and add failed label
              try {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  name: 'auto-merging'
                });
                
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  labels: ['auto-merge-failed']
                });
              } catch (e) {
                console.log('Could not manage labels after merge failure:', e.message);
              }
              
              throw error;
            }